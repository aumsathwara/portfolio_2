```mdx
---
title: "Getting Started with Model Context Protocol (MCP): Building a File System Server and Client"
publishedAt: "2024-06-22"
summary: "Learn about the Model Context Protocol (MCP), its purpose, and how to implement a simple file system server with a generic client on your local machine."
---

## Introducing Model Context Protocol: A New Way to Extend AI Capabilities

The Model Context Protocol (MCP) represents a significant advancement in how AI models interact with external systems and access real-time data. At its core, MCP is a standardized communication protocol that enables AI models to request information from or perform actions through external tools while maintaining a consistent interface. This capability is particularly valuable when AI systems need to access up-to-date information, interact with files, or perform specialized computations that fall outside their training data or embedded capabilities.

MCP addresses one of the fundamental limitations of large language models: their inability to directly interact with the external world. By providing a structured way for models to request and receive information from external systems, MCP bridges the gap between AI's language processing abilities and practical real-world applications. In this tutorial, we'll explore MCP's fundamentals and build a simple file system server and client that demonstrate its powerful capabilities in a practical context.

## Understanding Model Context Protocol Fundamentals

The Model Context Protocol operates on a client-server architecture where an AI model (client) can make requests to specialized servers that provide specific capabilities. These capabilities are defined through a set of operations and a schema that describes the data format for requests and responses.

### Core Components of MCP

MCP consists of several key components:

| Component | Description |
|-----------|-------------|
| Schema | Defines the structure of data and operations available through the protocol |
| Operations | Functions that can be invoked by clients, such as searching files or retrieving content |
| Capabilities | Collections of operations that servers advertise as available services |
| Context Items | Data objects exchanged between clients and servers |

The protocol uses JSON for data exchange, making it lightweight and compatible with various programming environments. A typical MCP interaction follows this pattern:

1. The client (AI model) identifies a need for external information
2. The client formulates a request following the MCP schema
3. The server processes the request and returns a response
4. The client incorporates the response into its reasoning or output

```bash
// Example of a basic MCP request structure
const mcpRequest = {
  operation: "fileSystem.searchFiles",
  parameters: {
    query: "*.txt",
    directory: "/documents"
  }
};
```

## Setting Up Your Development Environment for MCP

Before implementing our MCP file system server and client, we need to set up the necessary development environment. For this tutorial, we'll use Node.js as our platform.

First, create a new directory for your project:

```bash
mkdir mcp-filesystem-demo
cd mcp-filesystem-demo
npm init -y
```

Next, install the required dependencies:

```bash
npm install @mcp/protocol @mcp/server express cors
```

Create a basic project structure:

```bash
mkdir src
mkdir src/server
mkdir src/client
touch src/server/index.js
touch src/client/index.js
```

## Implementing a File System MCP Server

Now, let's implement a file system server that exposes operations for browsing and interacting with the local file system. This server will allow AI models to search for files, read their contents, and get information about the file system through the MCP protocol.

Create the server implementation in `src/server/index.js`:

```javascript
const express = require('express');
const cors = require('cors');
const fs = require('fs').promises;
const path = require('path');
const { MCPServer, createMCPHandler } = require('@mcp/server');

// Initialize Express app
const app = express();
app.use(cors());
app.use(express.json());

// Define the file system capabilities
const fileSystemCapability = {
  name: "fileSystem",
  description: "Access and manipulate the file system",
  operations: {
    // List files in a directory
    listFiles: {
      description: "List files in a directory",
      parameters: {
        directory: {
          type: "string",
          description: "Directory path to list files from"
        }
      },
      handler: async ({ directory }) => {
        try {
          const files = await fs.readdir(path.resolve(directory || '.'));
          return { files };
        } catch (error) {
          throw new Error(`Failed to list files: ${error.message}`);
        }
      }
    },
    
    // Read file content
    readFile: {
      description: "Read the content of a file",
      parameters: {
        path: {
          type: "string",
          description: "Path to the file"
        }
      },
      handler: async ({ path: filePath }) => {
        try {
          const content = await fs.readFile(path.resolve(filePath), 'utf-8');
          return { content };
        } catch (error) {
          throw new Error(`Failed to read file: ${error.message}`);
        }
      }
    },
    
    // Search files by pattern
    searchFiles: {
      description: "Search for files matching a pattern",
      parameters: {
        directory: {
          type: "string",
          description: "Directory to search in"
        },
        pattern: {
          type: "string",
          description: "Search pattern (e.g., '*.js')"
        }
      },
      handler: async ({ directory, pattern }) => {
        try {
          const dir = path.resolve(directory || '.');
          const allFiles = await fs.readdir(dir, { withFileTypes: true });
          
          // Simple pattern matching implementation
          const regex = new RegExp(pattern.replace(/\*/g, '.*'));
          const matchingFiles = allFiles
            .filter(file => regex.test(file.name))
            .map(file => ({
              name: file.name,
              isDirectory: file.isDirectory(),
              path: path.join(directory, file.name)
            }));
          
          return { matches: matchingFiles };
        } catch (error) {
          throw new Error(`Failed to search files: ${error.message}`);
        }
      }
    }
  }
};

// Create the MCP server instance
const mcpServer = new MCPServer({
  capabilities: [fileSystemCapability]
});

// Set up the MCP endpoint
app.post('/mcp', createMCPHandler(mcpServer));

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`MCP File System server running on port ${PORT}`);
});
```

This server exposes three operations:
- `listFiles` - Lists all files in a directory
- `readFile` - Reads and returns file content
- `searchFiles` - Searches for files matching a pattern

## Building a Generic MCP Client

Now let's implement a generic client that can communicate with our MCP server. This client will be capable of sending requests to the server and handling the responses.

Create the client implementation in `src/client/index.js`:

```javascript
const fetch = require('node-fetch');

class MCPClient {
  constructor(serverUrl) {
    this.serverUrl = serverUrl;
  }

  // Fetch capabilities from the server
  async getCapabilities() {
    try {
      const response = await fetch(`${this.serverUrl}/mcp`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          operation: 'getCapabilities'
        })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('Error fetching capabilities:', error);
      throw error;
    }
  }

  // Execute an operation
  async executeOperation(operation, parameters) {
    try {
      const response = await fetch(`${this.serverUrl}/mcp`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          operation,
          parameters
        })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      return await response.json();
